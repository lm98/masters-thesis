%! Author = leona
%! Date = 09/02/24
% !TeX root = ../thesis-main.tex

\chapter{Design}
\label{chap:design}
This chapter aims to give the reader a comprehensive view of this thesis' design. First, we will present the architectural design of the system, then we will shift the focus on
the detailed design, where the system will also be described in terms of behavior and interaction.

\section{Architectural Design}
\label{sec:architectural-design}
In this section, we will present and discuss RuFi's architectural design, shown in figure \ref{fig:rufi-architecture}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/diagrams/img/rufi-architecture.png}
    \caption{RuFi's architectural design}
    \label{fig:rufi-architecture}
\end{figure}

In the figure, we can see the following components:

\begin{itemize}
    \item \textbf{rf-core}: this component defines key abstractions, such as the fundamental aggregate operators, builtins and a virtual machine;
    \item \textbf{rf-distributed}: this component defines concepts related to the distributed execution of aggregate programs.
          In particular, it defines core abstractions related to networking and message passing, as well as an implementation of the computational model discussed in \ref{par:comp-model};
    \item \textbf{rf-distributed-impl}: this component exposes a standard implementation for the concepts defined in \textbf{rf-distributed}.
          The choice of separating the abstraction definitions and the implementations will be discussed in section \ref{subsec:rufi-distributed};
    \item \textbf{rf-gradient}: this component is a library exposing the gradient algorithm as an aggregate program.
\end{itemize}

\subsection{RuFi Core}
\label{subsec:rufi-core}
As mentioned in \ref{sec:architectural-design}, the module RuFi Core contains all the fundamental abstractions needed to start writing and evaluating aggregate programs.
Its structure is represented by the diagram in figure \ref{fig:rufi-core-architecture}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{figures/diagrams/img/rufi-core-architecture.png}
    \caption{RuFi Core's architectural design}
    \label{fig:rufi-core-architecture}
\end{figure}

\begin{itemize}
    \item \textbf{round-vm}: This module defines a virtual machine for executing and evaluating aggregate programs and also other related concepts like the VM's status,
          the path, the execution context and the device exports, all of which will be discussed in more detail in section \ref{sec:detailed-design};
    \item \textbf{lang}: this module defines the fundamental aggregate operators, such as \textit{rep}, \textit{nbr}, \textit{foldhood}, \textit{branch} and some important builtin functions like \textit{foldhood plus} and \textit{mux};
    \item \textbf{macros}: this module exports some declarative macros that aim to simplify the writing of aggregate programs;\
    \item \textbf{execution}: this module contains functions for evaluating aggregate programs alongside the virtual machine.
\end{itemize}

\subsection{RuFi Distributed}
\label{subsec:rufi-distributed}
This module, as described in \ref{sec:architectural-design}, defines concepts related to the distributed execution of aggregate programs.
Its structure is represented by the diagram in figure \ref{fig:rufi-distributed-architecture}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/diagrams/img/rufi-distributed-architecture.png}
    \caption{RuFi Distributed's architectural design}
    \label{fig:rufi-distributed-architecture}
\end{figure}

In the diagram, we see the following elements:

\begin{itemize}
    \item \textbf{network}: this module defines abstractions for networking operations;
    \item \textbf{mailbox}: this module defines the logic of incoming message processing;
    \item \textbf{time}: this module defines some time-related operations that can be leveraged during the execution cycle;
    \item \textbf{discovery}: this module exposes traits for the discovery of possible neighbors and the logic for setting up neighboring sensors;
    \item \textbf{platform}: this module brings all the other functionalities together through the platform structure, which is responsible for managing the execution cycle of the aggregate programs;
\end{itemize}

\section{Detailed Design}
\label{sec:detailed-design}
This subsection aims to explain in more detail some component design choices that are regarded as interesting or important to understand the whole system.
After that, we will analyze the system in terms of behavior and interaction.

\subsection{RuFi Core}
\subsubsection{Round VM}
The Round Virtual Machine is the operating heart of the RuFi framework. It is responsible for managing the state of the computation and generating the \ac{ast} of the aggregate program.
Each core language construct leverages the VM functionalities in its implementation.
In the class diagram in figure \ref{fig:round-vm-class}, we can see the elements that compose the VM.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/diagrams/img/round-vm-class.png}
    \caption{Round VM class diagram}
    \label{fig:round-vm-class}
\end{figure}

The Slot is a representation of a core construct of the \ac{ac} inside the \ac{ast}. A Path is nothing other than a sequence of Slots, denoting a chain of aggregate operations.\\
A level above, the Export represents the entire \ac{ast} of the aggregate program, decorated with the value computed at each Path. The Export is also shared between neighbors during each
computation round.\\
The VMStatus encapsulates the execution state: it has a representation of the execution stack and the current Path being evaluated.\\
The Context represents the execution context for the device and contains relevant information such as the device identifier, and the device's sensors alongside the exports of all the neighborhood.\\
Above all, the RoundVM is responsible for generating the \ac{ast} and evaluate functions, and it does so with the \textit{nest} function, which gets executed when an aggregate program is called
and causes the VM to push a new Slot into the current Path.

\subsubsection{Language}
The language includes all the core constructs and built-in functions. Since each core construct call grows the \ac{ast} by one Slot, each language construct and built-in function has
a dependency on the RoundVM, and this is reflected in their signatures. For example the $nbr\{e\}$ function, now 

\subsection{RuFi Distributed}
%NETWORK, PLATFORM


\subsection{Behavior}
%Platform execution cycle w/ activity diagram


\subsection{Interaction}
%Neighbor communication w/ sequence diagram

